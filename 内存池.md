## MR_malloc内存池项目

### 项目版本：1.0

**时间：2025.05.16**

**说明：本内存池属于第一个单线程版本 **

**主要功能是为了给频繁请求和释放内存的线程提供更高效的操作 **

**主要原理是缓存了内存 且对申请的块按一定规则进行内存对齐 减少了内存外碎片的产生 后续本项目会持续升级更新**

**当前功能：单线程下，支持小于128B的内存分配和释放，设置定长大块内存分配，并可按需进行动态增长**

#### 一、定长内存池的实现

定长内存池是最简单的内存池，其基本原理就是先分配一个大块的内存，







##### 

#### 项目版本：1.1

**时间：2025.05.23**

**当前功能：**

#### 二、多级缓存总体设计思路

多级缓存的设计思路主要如下图所示

![屏幕截图 2025-06-11 172947](C:\Users\Hmr\Desktop\MR_malloc\photo\屏幕截图 2025-06-11 172947.png)



##### 1.大块内存下的内存对齐规则和分配规则

在操作系统中malloc分配方式为低于128KB的内存请求按照brk()移动堆指针来实现，大于128KB的内存请求则通过mmap()映射文件和匿名页来获得内存，前者的好处自然是更简单，且自带回收机制，free的时候不必还给操作系统，而mmap则会返还给操作系统，调用mmap次数过多后就会导致CPU开销较大，由于在不同的业务场景中也有可能会涉及到使用超大的页内存，例如数据库页等，因此一个合格的内存池必须考虑设计128KB以下和128KB以上的内存分配，但由于内存池本身**不能过度设计**，也就是设计思路围绕单次申请的内存不超过256KB的情况，当大于256KB的情况就交给系统的malloc函数

tcmalloc的官方对齐规则并不是256KB内的所有块都按照8B的方式对齐，也就是说在某一范围内是8B，随后变为16B、128B、1024B、8*1024B规则，按照这个规则从1B~256KB原本26万多个分配节点（桶）只用160个桶即可解决，tcmalloc的具体分配规则如下：

![image-20250524164919511](C:\Users\Hmr\Desktop\MR_malloc\photo\image-20250524164919511.png)

这种分配范围和对齐粒度有自己的使用场景和优势，但考虑到前1KB的分配其实可以更为细化，考虑到操作系统内部采用了SLAB分配器来管理页内存的小块内存，所以分配的粒度不能太高，最大不能超过512个小对象，因此本项目采用的分配范围和对齐粒度如下：

![image-20250524165345601](C:\Users\Hmr\Desktop\MR_malloc\photo\image-20250524165345601.png)

采用这种分配方式和对齐规则只需要104个桶，相对来讲内存池本身所占的空间更小，且对于小块内存的空间利用率更高，那么对于_freelists的定义则为如下方式：

```cpp
// FREELISTSIZE = 104
void* _freelists[FREELISTSIZE];
```

那么确定了对齐规则， 我们就需要来根据请求的内存大小来计算对应桶的下标和对齐规则

##### 1.THREADCACHE的设计





##### 2.CENTRALCACHE的设计



内存池的设计的时候，现在架构是这样，一个span，管理一个或者多个页，每个span都按照得到的页总量切好了对应的小块内存，span对应的桶是管理256B的小块内存的，是由这个span管理的8KB的页切分而来的，得到的链表是有32个结点，这些结点被使用过后就从链表里面移出去了，现在问题是如果不记录这些小块内存的地址信息，那么返还回来的小块内存就不会按照原本切分的顺序组成链表，也就无法重新组成一个页内存，无法返还给下一层管理页的模块，那么随着时间推移底层分配页的模块回收到的页都不是原来分出去的页





##### 3.PAGECACHE的设计

















