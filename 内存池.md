### MR_malloc内存池项目

#### 项目版本：1.0

**时间：2025.05.16**

**说明：本内存池属于第一个单线程版本 **

**主要功能是为了给频繁请求和释放内存的线程提供更高效的操作 **

**主要原理是缓存了内存 且对申请的块按一定规则进行内存对齐 减少了内存外碎片的产生 后续本项目会持续升级更新**

**当前功能：单线程下，支持小于128B的内存分配和释放，设置定长大块内存分配，并可按需进行动态增长**

##### 1.定长内存池的实现

定长内存池是最简单的内存池，其基本原理就是先分配一个大块的内存，

##### 2.线程库的基本使用和线程函数的生命周期管理

c++11自带的线程库如下：

```c++
#include <thread>
std::thread t(function_name, args...);
```

其中function_name是传递给线程的入口函数，args是函数的参数，由于创建的线程独立于主线程运行，因此当主线程退出时，子线程就会被强行退出，因此为了避免这种情况，可以采用join()方法，让主线程等待子线程任务执行完毕才结束主线程

```c++
#include <iostream>
#include <thread>
void print_message(const std::string& message)
{    
	std::cout << message << std::endl;
}
int main() {    	
		std::thread t(print_message, "Thread 1");    
        t.join();    
        std::cout << "Thread detached" << std::endl;    
        return 0;
}
```

这样可以保证在主函数（进程）调用return 0的时候子线程的打印也能结束，常用的成员函数还有：

```c++
detach()   // 将线程与 std::thread 对象分离，允许线程在后台独立运行。一旦线程分离，就不能再与 std::thread 对象交互（如不能调用 join()）
joinable() // 检查线程对象是否关联一个可加入的线程，返回一个布尔值，如果线程可以被join()或detach()，则返回true，否则返回false
```

数据的生命周期问题：

**①传递临时变量**

```c++
#include <iostream>
#include <thread>
void foo(int& x) {
    x += 1;
}
int main() {
    std::thread t(foo, 1); // 传递临时变量
    t.join();
    return 0;
}
```

**②指针访问的局部临时变量**

```c++
#include <iostream>
#include <thread>
void foo(int* ptr) {
    std::cout << *ptr << std::endl; // 访问已经被销毁的指针
}
int main() {
    int x = 1;
    std::thread t(foo, &x); // 传递指向局部变量的指针
    t.join();
    return 0;
}
```

**③类成员函数作为入口函数，对象实例被提前释放了**

```c++
#include <iostream>
#include <thread>

class MyClass {
public:
    void func() {
        std::cout << "Thread " << std::this_thread::get_id() 
        << " started" << std::endl;
        // do some work
        std::cout << "Thread " << std::this_thread::get_id() 
        << " finished" << std::endl;
    }
};

int main() {
    MyClass obj;
    std::thread t(&MyClass::func, &obj);
    // obj 被提前销毁了，会导致未定义的行为
    return 0;
}
```

更改方法：

①不传递临时变量，而是传递持久的对象（例如左值），右值是临时的，且不能将字面量作为引用参数传递，因此改法如下：

```c++
#include <iostream>
#include <thread>

void foo(int& x) {
    x += 1; // 现在可以修改 x，因为它不是 const
}

int main() {
    int y = 1; // 创建一个左值变量
    std::thread t(foo, std::ref(y)); // 使用 std::ref 传递 y 的引用
    t.join();
    std::cout << y << std::endl; // 输出 2，因为 y 被修改了
    return 0;
}
```

②其实本身的指针指向的临时变量理论上在使用t.join()的时候是不会被销毁的，但由于编译器的优化或者跨平台等不统一的问题，C++ 标准并不保证局部变量的销毁与线程执行的精确顺序，因此需要手动管理这个变量的生命周期，在堆上面创建

```c++
#include <iostream>
#include <thread>
void foo(int* ptr) {
    std::cout << *ptr << std::endl;
    delete ptr; // 在使用完指针后，需要手动释放内存
}
int main() {
    int* ptr = new int(1); // 在堆上分配一个整数变量
    std::thread t(foo, ptr); // 将指针传递给线程
    t.join();
    return 0;
}
```

③在创建线程之后，类实例化对象立即被销毁了，这会导致在线程执行时无法访问对象，为了避免这个问题，可以使用 std::shared_ptr 来管理类对象的生命周期，确保在线程执行期间对象不会被销毁。具体来说，可以在创建线程之前，将类对象的指针封装在一个 std::shared_ptr 对象中，并将其作为参数传递给线程。这样，在线程执行期间，即使类对象的所有者释放了其所有权，std::shared_ptr 仍然会保持对象的生命周期，直到线程结束

```c++
#include <iostream>
#include <thread>
#include <memory>

class MyClass {
public:
    void func() {
        std::cout << "Thread " << std::this_thread::get_id() 
        << " started" << std::endl;
        // do some work
        std::cout << "Thread " << std::this_thread::get_id() 
        << " finished" << std::endl;
    }
};

int main() {
    std::shared_ptr<MyClass> obj = std::make_shared<MyClass>();
    std::thread t(&MyClass::func, obj);
    t.join();
    return 0;
}
```

##### 3.多线程操作数据的互斥量以及死锁问题

#### 项目版本：1.1

**时间：2025.05.23**

**当前功能：**

##### 1.大块内存下的内存对齐规则和分配规则

​		在操作系统中malloc分配方式为低于128KB的内存请求按照brk()移动堆指针来实现，大于128KB的内存请求则通过mmap()映射文件和匿名页来获得内存，前者的好处自然是更简单，且自带回收机制，free的时候不必还给操作系统，而mmap则会返还给操作系统，调用mmap次数过多后就会导致CPU开销较大，由于在不同的业务场景中也有可能会涉及到使用超大的页内存，例如数据库页等，因此一个合格的内存池必须考虑设计128KB以下和128KB以上的内存分配，但由于内存池本身**不能过度设计**，也就是设计思路围绕单次申请的内存不超过256KB的情况，当大于256KB的情况就交给系统的malloc函数

​		tcmalloc的官方对齐规则并不是256KB内的所有块都按照8B的方式对齐，也就是说在某一范围内是8B，随后变为16B、128B、1024B、8*1024B规则，按照这个规则从1B~256KB原本26万多个分配节点（桶）只用160个桶即可解决，tcmalloc的具体分配规则如下：

![image-20250524164919511](C:\Users\16969\Desktop\MR_malloc\photo\image-20250524164919511.png)

​		这种分配范围和对齐粒度有自己的使用场景和优势，但考虑到前1KB的分配其实可以更为细化，考虑到操作系统内部采用了SLAB分配器来管理页内存的小块内存，所以分配的粒度不能太高，最大不能超过512个小对象，因此本项目采用的分配范围和对齐粒度如下：

![image-20250524165345601](C:\Users\16969\Desktop\MR_malloc\photo\image-20250524165345601.png)

​		采用这种分配方式和对齐规则只需要104个桶，相对来讲内存池本身所占的空间更小，且对于小块内存的空间利用率更高，那么对于_freelists的定义则为如下方式：

```cpp
// FREELISTSIZE = 104
void* _freelists[FREELISTSIZE];
```

​		那么确定了对齐规则， 我们就需要来根据请求的内存大小来计算对应桶的下标和对齐规则























